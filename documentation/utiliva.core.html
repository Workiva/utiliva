<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>utiliva.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Utiliva</span> <span class="project-version">0.1.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utiliva</span></div></div></li><li class="depth-2 branch"><a href="utiliva.alpha.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>alpha</span></div></a></li><li class="depth-2 branch"><a href="utiliva.comparator.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>comparator</span></div></a></li><li class="depth-2 branch"><a href="utiliva.control.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>control</span></div></a></li><li class="depth-2 branch current"><a href="utiliva.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="utiliva.macros.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>macros</span></div></a></li><li class="depth-2 branch"><a href="utiliva.plasmodesma.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>plasmodesma</span></div></a></li><li class="depth-2 branch"><a href="utiliva.recursion.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>recursion</span></div></a></li><li class="depth-2 branch"><a href="utiliva.sorted-cache.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sorted-cache</span></div></a></li><li class="depth-2"><a href="utiliva.uuid.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>uuid</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="utiliva.core.html#var-distinct-by"><div class="inner"><span>distinct-by</span></div></a></li><li class="depth-1"><a href="utiliva.core.html#var-group-by"><div class="inner"><span>group-by</span></div></a></li><li class="depth-1"><a href="utiliva.core.html#var-group-like"><div class="inner"><span>group-like</span></div></a></li><li class="depth-1"><a href="utiliva.core.html#var-keep"><div class="inner"><span>keep</span></div></a></li><li class="depth-1"><a href="utiliva.core.html#var-keepcat"><div class="inner"><span>keepcat</span></div></a></li><li class="depth-1"><a href="utiliva.core.html#var-locking-vswap.21"><div class="inner"><span>locking-vswap!</span></div></a></li><li class="depth-1"><a href="utiliva.core.html#var-map-keys"><div class="inner"><span>map-keys</span></div></a></li><li class="depth-1"><a href="utiliva.core.html#var-map-vals"><div class="inner"><span>map-vals</span></div></a></li><li class="depth-1"><a href="utiliva.core.html#var-merge-sorted"><div class="inner"><span>merge-sorted</span></div></a></li><li class="depth-1"><a href="utiliva.core.html#var-merge-sorted-by"><div class="inner"><span>merge-sorted-by</span></div></a></li><li class="depth-1"><a href="utiliva.core.html#var-partition-map"><div class="inner"><span>partition-map</span></div></a></li><li class="depth-1"><a href="utiliva.core.html#var-partition-pmap"><div class="inner"><span>partition-pmap</span></div></a></li><li class="depth-1"><a href="utiliva.core.html#var-piecewise-map"><div class="inner"><span>piecewise-map</span></div></a></li><li class="depth-1"><a href="utiliva.core.html#var-piecewise-pmap"><div class="inner"><span>piecewise-pmap</span></div></a></li><li class="depth-1"><a href="utiliva.core.html#var-reduce-indexed"><div class="inner"><span>reduce-indexed</span></div></a></li><li class="depth-1"><a href="utiliva.core.html#var-sorted-zipmap"><div class="inner"><span>sorted-zipmap</span></div></a></li><li class="depth-1"><a href="utiliva.core.html#var-thread-local"><div class="inner"><span>thread-local</span></div></a></li><li class="depth-1"><a href="utiliva.core.html#var-thread-local*"><div class="inner"><span>thread-local*</span></div></a></li><li class="depth-1"><a href="utiliva.core.html#var-zip"><div class="inner"><span>zip</span></div></a></li><li class="depth-1"><a href="utiliva.core.html#var-zip-from"><div class="inner"><span>zip-from</span></div></a></li><li class="depth-1"><a href="utiliva.core.html#var-zip-to"><div class="inner"><span>zip-to</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">utiliva.core</h1><div class="doc"><pre class="plaintext"></pre></div><div class="public anchor" id="var-distinct-by"><h3>distinct-by</h3><div class="usage"><code>(distinct-by f)</code><code>(distinct-by f coll)</code></div><div class="doc"><pre class="plaintext">Returns a lazy sequence of the elements of coll, removing any
elements that return duplicate values when passed to a function f.</pre></div></div><div class="public anchor" id="var-group-by"><h3>group-by</h3><div class="usage"><code>(group-by f coll)</code><code>(group-by xform f coll)</code></div><div class="doc"><pre class="plaintext">Behaves just like clojure.core/group-by, but optionally takes an xform
as first argument to transform the inputs before grouping:
(group-by (map inc) even? (range 10))</pre></div></div><div class="public anchor" id="var-group-like"><h3>group-like</h3><div class="usage"><code>(group-like flat grouped)</code></div><div class="doc"><pre class="plaintext">(group-like [:a :b :c :d :e] [[1 2] [3 4 5]])
=&gt; [(:a :b) (:c :d :e)]</pre></div></div><div class="public anchor" id="var-keep"><h3>keep</h3><div class="usage"><code>(keep f)</code><code>(keep f coll)</code><code>(keep f coll &amp; colls)</code></div><div class="doc"><pre class="plaintext">Returns a lazy sequence of the non-nil results of (f item). Note that this
means false return values will be included. f must be free of side-effects.
Returns a transducer when no collection is provided.
Differs from clojure.core/keep in that it can work with multiple collections
the way map can.</pre></div></div><div class="public anchor" id="var-keepcat"><h3>keepcat</h3><div class="usage"><code>(keepcat)</code><code>(keepcat f)</code><code>(keepcat f &amp; colls)</code></div><div class="doc"><pre class="plaintext">mapcat : map :: keepcat : keep
</pre></div></div><div class="public anchor" id="var-locking-vswap.21"><h3>locking-vswap!</h3><h4 class="type">macro</h4><div class="usage"><code>(locking-vswap! vol f &amp; args)</code></div><div class="doc"><pre class="plaintext">Version of vswap! that locks the volatile.
</pre></div></div><div class="public anchor" id="var-map-keys"><h3>map-keys</h3><div class="usage"><code>(map-keys f)</code><code>(map-keys f k-&gt;v)</code></div><div class="doc"><pre class="plaintext">Maps a function across the keys of a MapEntry collection. Returns
a sequence. If you want a new map efficiently constructed, use
(into {} (map-keys f) c).</pre></div></div><div class="public anchor" id="var-map-vals"><h3>map-vals</h3><div class="usage"><code>(map-vals f)</code><code>(map-vals f k-&gt;v)</code></div><div class="doc"><pre class="plaintext">Maps a function across the vals of a MapEntry collection. Returns
a sequence. If you want a new map efficiently constructed, use
(into {} (map-vals f) c).</pre></div></div><div class="public anchor" id="var-merge-sorted"><h3>merge-sorted</h3><div class="usage"><code>(merge-sorted cs)</code></div><div class="doc"><pre class="plaintext">Given a number of sorted collections, this returns a vector containing all the items
from those collections, sorted.</pre></div></div><div class="public anchor" id="var-merge-sorted-by"><h3>merge-sorted-by</h3><div class="usage"><code>(merge-sorted-by f cs)</code></div><div class="doc"><pre class="plaintext">Given a number of collections sorted under the projection defined by f,
this returns a vector containing all the items from those collections, all
sorted under the projection defined by f.</pre></div></div><div class="public anchor" id="var-partition-map"><h3>partition-map</h3><div class="usage"><code>(partition-map pred fmap coll)</code><code>(partition-map pred fmap coll &amp; colls)</code></div><div class="doc"><pre class="plaintext">Similar to piecewise-map. This partitions the collection by the result of (pred x) for
each x in coll, then applies the functions in fmap directly to the partitions whole,
rather than on individual elements. Even so, the element-wise ordering is preserved.
Usage:
(partition-map even? {true reverse false #(map - %)} (range 10))
If a function is not specified, defaults to the value of :default in fmap; if that
is not defined, defaults to identity.
Supplied functions are never called on an empty partition.</pre></div></div><div class="public anchor" id="var-partition-pmap"><h3>partition-pmap</h3><div class="usage"><code>(partition-pmap pred fmap coll)</code><code>(partition-pmap pred fmap coll &amp; colls)</code></div><div class="doc"><pre class="plaintext">Similar to piecewise-map. This partitions the collection by the result of (pred x) for
each x in coll, then applies the functions in fmap directly to the partitions whole,
rather than mapping across them.
rather than on individual elements. Even so, the element-wise ordering is preserved.
Usage:
(partition-map even? {true reverse false #(map - %)} (range 10))
If a function is not specified, defaults to the value of :default in fmap; if that
is not defined, defaults to identity.
Supplied functions are never called on an empty partition.</pre></div></div><div class="public anchor" id="var-piecewise-map"><h3>piecewise-map</h3><div class="usage"><code>(piecewise-map pred fmap)</code><code>(piecewise-map pred fmap coll)</code><code>(piecewise-map pred fmap coll &amp; colls)</code></div><div class="doc"><pre class="plaintext">Declaratively defines and maps a piecewise function across a collection, with pieces
split on the result of (pred x) for each x in coll. Usage:
(piecewise-map even? {true inc, false dec} (range 10))
=&gt; (1 0 3 2 5 4 7 6 9 8)
If a function is not specified, defaults to the value of :default in fmap; if that
is not defined, defaults to identity.</pre></div></div><div class="public anchor" id="var-piecewise-pmap"><h3>piecewise-pmap</h3><div class="usage"><code>(piecewise-pmap pred fmap coll)</code><code>(piecewise-pmap pred fmap coll &amp; colls)</code></div><div class="doc"><pre class="plaintext">Declaratively defines and maps a piecewise function across a collection, with pieces
split on the result of (pred x) for each x in coll. Usage:
(piecewise-map even? {true inc, false dec} (range 10))
=&gt; (1 0 3 2 5 4 7 6 9 8)
If a function is not specified, defaults to the value of :default in fmap; if that
is not defined, defaults to identity.</pre></div></div><div class="public anchor" id="var-reduce-indexed"><h3>reduce-indexed</h3><div class="usage"><code>(reduce-indexed f coll)</code><code>(reduce-indexed f val coll)</code></div><div class="doc"><pre class="plaintext">Similar to map-indexed. The reducing function should take args [res idx val].
More or less equivalent to (reduce-kv f (vec coll)), which would rely on the fact
that vectors are indexed.</pre></div></div><div class="public anchor" id="var-sorted-zipmap"><h3>sorted-zipmap</h3><div class="usage"><code>(sorted-zipmap keys vals)</code><code>(sorted-zipmap fn keys vals)</code></div><div class="doc"><pre class="plaintext">Exactly like zipmap, except the resulting map is sorted. Optionally accepts a comparator.
Motivation: faster than zipmapping then sorting.</pre></div></div><div class="public anchor" id="var-thread-local"><h3>thread-local</h3><h4 class="type">macro</h4><div class="usage"><code>(thread-local &amp; body)</code></div><div class="doc"><pre class="plaintext">Takes a body of expressions, and returns a java.lang.ThreadLocal object.
 (see <a href="http://download.oracle.com/javase/6/docs/api/java/lang/ThreadLocal.html)">http://download.oracle.com/javase/6/docs/api/java/lang/ThreadLocal.html)</a>.
To get the current value of the thread-local binding, you must deref (@) the
thread-local object. The body of expressions will be executed once per thread
and future derefs will be cached.
Note that while nothing is preventing you from passing these objects around
to other threads (once you deref the thread-local, the resulting object knows
nothing about threads), you will of course lose some of the benefit of having
thread-local objects.</pre></div></div><div class="public anchor" id="var-thread-local*"><h3>thread-local*</h3><div class="usage"><code>(thread-local* init)</code></div><div class="doc"><pre class="plaintext">Non-macro version of thread-local - see documentation for same.
</pre></div></div><div class="public anchor" id="var-zip"><h3>zip</h3><div class="usage"><code>(zip f1 f2)</code><code>(zip f1 f2 c)</code><code>(zip f1 f2 c &amp; cs)</code></div><div class="doc"><pre class="plaintext">Zips two functions across the input collection(s). Returns a MapEntry sequence.
Returns a transducer if no collection(s) are provided. Similar to (map juxt).</pre></div></div><div class="public anchor" id="var-zip-from"><h3>zip-from</h3><div class="usage"><code>(zip-from c)</code></div><div class="doc"><pre class="plaintext">Stateful transducer. Create with collection c.
Returns a MapEntry seq [c-1 input-1] [c-2 input-2] ... until c is empty or
inputs are exhausted.</pre></div></div><div class="public anchor" id="var-zip-to"><h3>zip-to</h3><div class="usage"><code>(zip-to c)</code></div><div class="doc"><pre class="plaintext">Stateful transducer. Create with collection c.
Returns a MapEntry seq [input-1 c-1] [input-2 c-2] ... until c is empty or
inputs are exhausted.</pre></div></div></div></body></html>